"use strict";
/**
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileSystemWalletStoreV1 = void 0;
const IdentityConverter_1 = require("./IdentityConverter");
const path = require("path");
const fs = require("fs");
const util = require("util");
const _rimraf = require("rimraf");
const rimraf = util.promisify(_rimraf);
const encoding = "utf8";
const privateKeyExtension = "-priv";
class FileSystemWalletStoreV1 {
    constructor(directory) {
        this.converter = new IdentityConverter_1.IdentityConverter();
        this.directory = directory;
    }
    async get(label) {
        try {
            const user = await this.getUser(label);
            const privateKey = await this.getPrivateKey(user);
            const storeData = this.converter.userToStoreData(user, privateKey);
            const json = JSON.stringify(storeData);
            return Buffer.from(json, encoding);
        }
        catch (error) {
            return undefined;
        }
    }
    async list() {
        const dirEntries = await fs.promises.readdir(this.directory, { withFileTypes: true });
        const labels = dirEntries
            .filter((dirEntry) => dirEntry.isDirectory())
            .map((dirEntry) => dirEntry.name);
        const results = [];
        for (const label of labels) {
            try {
                await this.getUser(label);
                results.push(label);
            }
            catch (error) {
                // Not a valid user
            }
        }
        return results;
    }
    async put(label, data) {
        const json = data.toString(encoding);
        const storeData = JSON.parse(json);
        const { user, privateKey } = this.converter.storeDataToUser(storeData, label);
        await this.createIdentityDir(label);
        await this.writeUser(user, label);
        if (privateKey) {
            await this.writePrivateKey(user, privateKey);
        }
    }
    async remove(label) {
        const identityDir = this.getIdentityDir(label);
        await rimraf(identityDir);
    }
    async getUser(label) {
        const userPath = this.getUserPath(label);
        const userData = await fs.promises.readFile(userPath);
        return JSON.parse(userData.toString(encoding));
    }
    getUserPath(label) {
        const identityDir = this.getIdentityDir(label);
        return path.join(identityDir, label);
    }
    getIdentityDir(label) {
        return path.join(this.directory, label);
    }
    async getPrivateKey(user) {
        const keyPath = this.getPrivateKeyPath(user);
        try {
            const keyData = await fs.promises.readFile(keyPath);
            return keyData.toString(encoding).trim();
        }
        catch (error) {
            // No private key
            return undefined;
        }
    }
    getPrivateKeyPath(user) {
        const identityDir = this.getIdentityDir(user.name);
        const file = user.enrollment.signingIdentity + privateKeyExtension;
        return path.join(identityDir, file);
    }
    async createIdentityDir(label) {
        const identityDir = this.getIdentityDir(label);
        await fs.promises.mkdir(identityDir);
    }
    async writeUser(user, label) {
        const userJson = JSON.stringify(user);
        const userData = Buffer.from(userJson);
        const userPath = this.getUserPath(label);
        await fs.promises.writeFile(userPath, userData);
    }
    async writePrivateKey(user, privateKey) {
        const privateKeyPath = this.getPrivateKeyPath(user);
        await fs.promises.writeFile(privateKeyPath, privateKey);
    }
}
exports.FileSystemWalletStoreV1 = FileSystemWalletStoreV1;
//# sourceMappingURL=FileSystemWalletStoreV1.js.map